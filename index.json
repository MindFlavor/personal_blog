[{"content":"SQL Server is very easy to interact with in .Net thanks to ADO.Net. There is no Rust port however. So how can you interact with SQL Server from a Rust application? As of now, the easiest is to use the official ODBC driver (get it here). It\u0026rsquo;s available for every major platform so your Rust code will remain cross-platform. As for Rust, there is an excellent crate called odbc that makes working with FFI easier.\nODBC The steps required to query a SQL Server instance are the following:\n Create the ODBC environment. Pick a driver and connect to the SQL Server instance. Create a statement. Execute the statement and read the resulting result set, one row at at time.  Create the environment The ODBC crate makes creating the environment trivial:\n1  letmutenv=create_environment_v3().unwrap();  While we are at it, we can ask the environment for the list of available ODBC drivers. There is a function called drivers() that does just that:\n1 2  letdrivers=env.drivers()?;println!(\u0026#34;drivers == {:?}\u0026#34;,drivers);  You should see the ODBC Driver for SQL Server amongst the available drivers. If not, make sure it\u0026rsquo;s properly installed following the aforementioned link.\nIn my case I only have the ODBC Driver 17 for SQL Server installed:\ndrivers == [DriverInfo { description: \u0026quot;ODBC Driver 17 for SQL Server\u0026quot;, attributes: {\u0026quot;Driver\u0026quot;: \u0026quot;/opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.7.so.2.1\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;Microsoft ODBC Driver 17 for SQL Server\u0026quot;, \u0026quot;UsageCount\u0026quot;: \u0026quot;1\u0026quot;} }] Note the description part, it\u0026rsquo;s the name we will pass to the ODBC connection string to bind it.\nConnect to the instance Now that we know the driver it\u0026rsquo;s just a matter of composing the connection string. Here you can find the complete docs but, for our sakes, we just want to specify the driver, the instance and the initial catalog. Integrated authentication will take care of passing our credentials to SQL Server.\nThe connection string in my case will be\nDriver={ODBC Driver 17 for SQL Server};Server=localhost;Database=tersa;Trusted_Connection=yes; You might want to replace Trusted_Connection=yes; with Uid=myUsername;Pwd=myPassword; if you want to use the SQL Server authentication.\nSo to get a connection we just need to call the connect_with_connection_string function of our environment:\n1  letconn=env.connect_with_connection_string(\u0026#34;Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=tersa;Trusted_Connection=yes;\u0026#34;)?;   Note: The documentation explicitly states that our connection must not outlive the generating environment. See https://docs.rs/odbc/0.17.0/odbc/struct.Environment.html#method.connect_with_connection_string.\n So far, so good! Let\u0026rsquo;s move to the query!\nCreate the statement We need to create a statement, link it to our connection and execute it.\n1 2  letstmt=Statement::with_parent(\u0026amp;conn)?;letstmt_prepared=stmt.prepare(\u0026#34;SELECT * FROM Cluster\u0026#34;)?;  Execute the statement Just call the, uh, execute function of our prepared statement:\n1  letexecution=stmt_prepared.execute()?;  The execution is an enum that can either be Data or NoData. We need to discriminate between the two:\n1 2 3 4 5 6 7 8  matchexecution{ResultSetState::NoData(_stmt)=\u0026gt;{println!(\u0026#34;no data!\u0026#34;);}ResultSetState::Data(_stmt)=\u0026gt;{println!(\u0026#34;data!\u0026#34;);}}   Note: Data and NoData are misleading. You should always receive a Data even if the returned recordset is empty. In other words, NoData does not mean \u0026ldquo;zero rows returned\u0026rdquo;!\n The statement with data can now be iterated to get each row, using the fetch function. In this example we are printing the second column of each row, interpreted as as String:\n1 2 3  whileletSome(mutcursor)=stmt.fetch()?{println!(\u0026#34;{:?}\u0026#34;,cursor.get_data::\u0026lt;String\u0026gt;(2)?);}  Putting all together:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Step 1. letmutenv=create_environment_v3().unwrap();// Step 2. letconn=env.connect_with_connection_string(\u0026#34;Driver={ODBC Driver 17 for SQL Server};Server=localhost;Database=tersa;Uid=sa;Pwd=PasaCulo00\u0026#34;)?;// Step 3. letstmt=Statement::with_parent(\u0026amp;conn)?;letstmt_prepared=stmt.prepare(\u0026#34;SELECT * FROM Cluster\u0026#34;)?;// Step 4. letexecution=stmt_prepared.execute()?;matchexecution{ResultSetState::NoData(_stmt)=\u0026gt;{println!(\u0026#34;no data!\u0026#34;);}ResultSetState::Data(mutstmt)=\u0026gt;{println!(\u0026#34;data!\u0026#34;);whileletSome(mutcursor)=stmt.fetch()?{println!(\u0026#34;{:?}\u0026#34;,cursor.get_data::\u0026lt;String\u0026gt;(2)?);}}}  Parameters Concatenating strings in T-SQL is dangerous: Bobby Tables will haunt you and make sure to screw you at the worst possible time. For this reason you can - and should - use parameters instead.\nIn ODBC is very easy to pass parameters to a statement, just make sure to do it before calling prepare. In this example we are passing a INT parameter:\n1 2 3 4 5 6 7 8 9  letstmt=odbc::Statement::with_parent(\u0026amp;conn)?;// This is our parameter (remember, the binding starts from one, not zero!) letcapacity=400;letstmt=stmt.bind_parameter(1,\u0026amp;capacity)?;letstmt_prepared=stmt.prepare(\u0026#34;INSERT INTO Cluster([Name], [Capacity]) VALUES(\u0026#39;Trekkies\u0026#39;, ?)\u0026#34;)?;letexecution=stmt_prepared.execute()?;   Note: bind_parameter takes a reference of our parameter value. To avoid making Rust\u0026rsquo;s borrow checker angry it\u0026rsquo;s best to bind the parameters as close to the statement execution as possible.\n At this point you might be wondering why I have not parametrized the value Trekkies as well. There is a known issue on how the ODBC driver for Linux and macOS handles UTF-8 that makes impossible to bind string values (check out here). It works in Windows so if you are only targeting Windows this issue does not apply to you.\nConnection pooling The SQL Server ODBC Driver supports connection pooling. Connection pooling allows connection reuse, greatly decreasing the overhead of small queries.\nWe can test the difference using this sample code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  usecrate::odbc_safe::Odbc3;useodbc::*;fn execute_one(env: \u0026amp;Environment\u0026lt;Odbc3\u0026gt;,)-\u0026gt; std::result::Result\u0026lt;(),Box\u0026lt;dynstd::error::Error+Send+Sync\u0026gt;\u0026gt;{letconn=env.connect_with_connection_string(\u0026#34;Driver={ODBC Driver 17 for SQL Server};Server=\u0026lt;your_instance\u0026gt;;Database=\u0026lt;your_db\u0026gt;;Uid=\u0026lt;your_user_id\u0026gt;;Pwd=\u0026lt;your_password\u0026gt;\u0026#34;,)?;letstmt=Statement::with_parent(\u0026amp;conn)?;letstmt_prepared=stmt.prepare(\u0026#34;SELECT * FROM Cluster\u0026#34;)?;letexecution=stmt_prepared.execute()?;matchexecution{ResultSetState::NoData(_stmt)=\u0026gt;{panic!();}ResultSetState::Data(mutstmt)=\u0026gt;whileletSome(_cursor)=stmt.fetch()?{},}Ok(())}fn main()-\u0026gt; std::result::Result\u0026lt;(),Box\u0026lt;dynstd::error::Error+Send+Sync\u0026gt;\u0026gt;{constITERATIONS: u128=1000;letenv=create_environment_v3().unwrap();letnow=std::time::Instant::now();for_in0..ITERATIONS{execute_one(\u0026amp;env)?;}println!(\u0026#34;elapsed microseconds for {} iterations = {}\u0026#34;,ITERATIONS,now.elapsed().as_micros());println!(\u0026#34;micros per query {}\u0026#34;,now.elapsed().as_micros()/ITERATIONS);Ok(())}  You can see for yourself, with a local connection it\u0026rsquo;s an order of magnitude faster!\nCare must be taken because the ODBC connection pooling behaves differently from the ADO.Net one. Amongst other things, ODBC connection pooling does not reset the connection when you close it (i.e. it won\u0026rsquo;t call sp_reset_connection behind the scenes). For this reason, unless you account for it during application development, it\u0026rsquo;s best to not enable it.\nIn Linux/MacOS, the setting is controlled by these lines in the odbcinst.ini:\n1 2 3 4 5  [ODBC] Pooling=Yes [ODBC Driver 17 for SQL Server] CPTimeout=\u0026lt;int value\u0026gt;   Change environment options ODBC allows to customize the environment you are using by calling the SQLSetEnvAttr function (SQLSetEnvAttr Function on Microsoft docs). This is useful for example if you want to change the connection pooling mode (per driver, per environment, driver aware or disable altogether).\nThe odbc crate does not, however, expose a safe interface for calling it.\nFear not, FFI comes to the rescue! The odbc crate reexports the relevant function in the ffi module. The signature is this one:\nIt\u0026rsquo;s definitely not Rust-y at all. The Microsoft docs tell us we need pass:\n A valid environment handle or NULL if we want to be a process level change. The attribute we want to change (odbc::ffi::EnvironmentAttribute::SQL_ATTR_CONNECTION_POOLING) The value we want to set as pointer. (ignored)  In Rust it becomes unsafe:\n1 2 3 4 5 6 7 8 9 10 11 12 13  letp_val=1as*mutstd::ffi::c_void;letnull_handle=0as*mutodbc::ffi::Env;unsafe{letret=odbc::ffi::SQLSetEnvAttr(null_handle,odbc::ffi::EnvironmentAttribute::SQL_ATTR_CONNECTION_POOLING,p_val,0);println!(\u0026#34;ret == {:?}\u0026#34;,ret);}   Happy Coding,\nFrancesco\n","permalink":"https://blog.mindflavor.it/posts/querying-sql-server-using-rust-via-odbc/","summary":"SQL Server is very easy to interact with in .Net thanks to ADO.Net. There is no Rust port however. So how can you interact with SQL Server from a Rust application? As of now, the easiest is to use the official ODBC driver (get it here). It\u0026rsquo;s available for every major platform so your Rust code will remain cross-platform. As for Rust, there is an excellent crate called odbc that makes working with FFI easier.","title":"Querying SQLServer using Rust via ODBC"},{"content":"Intro In this post we will build a very simple Prometheus exporter in Rust. Prometheus is a time-series database especially useful in storing and retrieving OS vital signs. It can be paired with Grafana in order to create beautiful dashboards, like this one below:\nPrometheus is peculiar because instead of receiving the events to store it goes on and retrieves them itself. There is no magic though: Prometheus just calls a preconfigured URI and expects a very specific plain text output. This is very elegant because this architecture decouples the service being monitored and the monitor adding an exporter service in between. It\u0026rsquo;s the exporter\u0026rsquo;s job to convert the service-specific metrics in a format Prometheus can understand and store.\nThere are tons of pre-made exporters allowing you to monitor the server CPU, the DHCP, etc\u0026hellip; with ease. But since this is dev post we won\u0026rsquo;t stop at combining tools written by others. Instead, we will build an exporter of our own. This will be a very simple exporter but I wanted to show you how easy it is to do it so hopefully you can implement an exporter on your own.\nThe goal We want to keep an eye on the size of a folder. Prometheus can store the folder size every 60 seconds and Grafana can plot the size over time beautifully. It also allows us to create alerts: we can, for example, be notified via Telegram if the folder grows beyond a threshold. But how we create the website needed by Prometheus in order to store the folder size? Enter Rust and an helper crate: Prometheus exporter base. Also, as a bonus, being Rust we will be sure the memory/CPU footprint will be low.\nPrometheus exporter base This crate is open source and MIT licensed (so you can use it freely) and it\u0026rsquo;s designed to help you create a Prometheus exporter. It will handle most of the boilerplate required by Prometheus (such as rejecting anything but GET verbs and only answering to the /metrics URL). It also provides methods to format the output properly. So first thing first we need to import it by adding the relevant entry to the [Dependencies] section of out Cargo.toml file. This post is written using the version 0.3.0 of the crate so if you end up using a newer version you might have to account for breaking changes (if any).\nThe documentation is very terse: https://docs.rs/prometheus_exporter_base/0.3.0/prometheus_exporter_base/ but don\u0026rsquo;t fret: all we have to do is to call the render_prometheus method.\nIts signature is this one:\nWhat a mouthful! Basically we need to pass a closure that will be called at every GET request. The closure should return a String or and error. Yes, Rust type system can get carried away. Let\u0026rsquo;s break down the methods one by one.\nBind address 1  addr: \u0026amp;SocketAddr,  This is the address our exporter will be listening to. We can pass 0.0.0.0 with a port of our choosing. For example this code will do:\n1  letaddr=([0,0,0,0],32221).into();  Options 1 2 3  options: OwhereO: Debug+Clone+Send+Sync+\u0026#39;static  The options can be anything and it will be passed back to our closure at every call. The O type must also be cloneable, debuggable (meaning it must be printable in debug mode) and also must be sendable between threads. It also has to last forever (the 'static lifetime). We do not need options so we create an empty type just for that. Notice how the derive trick makes it trivial:\n1 2  #[derive(Debug, Clone)]struct MyOptions{}  Closure 1 2 3  perform_request: PwhereP: FnOnce(Request\u0026lt;Body\u0026gt;,\u0026amp;Arc\u0026lt;O\u0026gt;)-\u0026gt; Box\u0026lt;dynFuture\u0026lt;Item=String,Error=Error\u0026gt;+Send+\u0026#39;static\u0026gt;+Send+Clone+\u0026#39;static,  This is a bit more complicated. What it means we must pass a function that takes the http Request as parameter. The second paramerer is the aforementioned custom option struct O, wrapped in an Arc (Arc allows multiple references of the underlying struct to be owned at the same time). The function must returns a Future: it must either resolve into a String - in case of success - or a failure::Error - in case something goes south. The bunch of other traits are generally less important besides the 'static lifetime. The 'static lifetime here warrants a mention: what it does is to restrict anything captured by the closure to live forever. In practice this just means that we either do not capture anything (easier) or make sure to move ownership into the closure.\nOur exporter Armed with this knowledge we can start creating a stub. Let\u0026rsquo;s put this code as the main function of our exporter:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  fn main(){letaddr=([0,0,0,0],32221).into();println!(\u0026#34;starting exporter on {}\u0026#34;,addr);render_prometheus(\u0026amp;addr,MyOptions{},|request,options|{Box::new({println!(\u0026#34;in our render_prometheus(request == {:?}, options == {:?})\u0026#34;,request,options);ok(\u0026#34;it\u0026#39;s working!\\n\u0026#34;.to_owned())})});}  It will compile and you will get a working webserver listening on port 32221 that:\n Will only allow GET verbs. Will only answer to the path /metrics as per Prometheus specification. Will run our code once invoked. Right now, it will just print something in the exporter\u0026rsquo;s console window and return a fixed string to the caller.  Let\u0026rsquo;s try it! After issuing cargo run in our crate we should be able to issue - in another terminal - curl http://localhost:32221/metrics -v. Since it\u0026rsquo;s a standard HTTP GET you can use a browser to check it just the same.\nNot bad for just few lines of crappy code!\nFolder size calculation Our stub right now doesn\u0026rsquo;t do anything useful. We want it to be able to calculate the size of a folder. Let\u0026rsquo;s write a function for that:\n1 2 3 4 5 6 7 8 9 10 11  fn calculate_file_size(path: \u0026amp;str)-\u0026gt; Result\u0026lt;u64,std::io::Error\u0026gt;{letmuttotal_size: u64 =0;forentryinread_dir(path)?{letp=entry?.path();ifp.is_file(){total_size+=p.metadata()?.len();}}Ok(total_size)}  This function does not calculate the subfolders size but for our purposes will do just fine. Let\u0026rsquo;s call it from our code. Start by adding this line to our main function:\n1  letfuture_log=done(calculate_file_size(\u0026#34;/var/log\u0026#34;)).from_err();  Note here the done(...) - from_err() dance that is common with future combinators. Now we replace the ok(\u0026quot;it's working\\n\u0026quot;.to_owned()) line with the future execution we just created:\n1 2 3  future_log.and_then(|total_size_log|{ok(format!(\u0026#34;{}\\n\u0026#34;,total_size_log))})  This is easy! Now if we run the exporter again we should receive the proper answer instead of a static string! Nice! Firefox screenshot below:\nJust for reference, now our code is like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #[derive(Debug, Clone)]struct MyOptions{}fn calculate_file_size(path: \u0026amp;str)-\u0026gt; Result\u0026lt;u64,std::io::Error\u0026gt;{letmuttotal_size: u64 =0;forentryinread_dir(path)?{letp=entry?.path();ifp.is_file(){total_size+=p.metadata()?.len();}}Ok(total_size)}fn main(){letaddr=([0,0,0,0],32221).into();println!(\u0026#34;starting exporter on {}\u0026#34;,addr);render_prometheus(\u0026amp;addr,MyOptions{},|request,options|{Box::new({println!(\u0026#34;in our render_prometheus(request == {:?}, options == {:?})\u0026#34;,request,options);letfuture_log=done(calculate_file_size(\u0026#34;/var/log\u0026#34;)).from_err();future_log.and_then(|total_size_log|{ok(format!(\u0026#34;{}\\n\u0026#34;,total_size_log))})})});}  Prometheus compliance This is all well and good but it does not mean our output is Prometheus compliant. In order to do so we should follow a specific format. Luckily the above helper crate has some methods to help us in this endeavor too. We just need to create an instance of PrometheusCounter. The new(...) constructor requires:\n A counter name. This is up to you to get correctly and I refer you the official Prometheus documentation for it. I will just use folder_size for this post. A counter type. Again, please refer to the Prometheus documentation for this. I will go with counter on this one. A counter help text. This is entirely optional but might help other people to understand what your counter is meant to do.  Once created we call the render_header() method so the crate will output the required header for our counter. The code will be like this:\n1 2  letpc=PrometheusCounter::new(\u0026#34;folder_size\u0026#34;,\u0026#34;counter\u0026#34;,\u0026#34;Size of the folder\u0026#34;);letmuts=pc.render_header();  That settles the header. All we need to do now is to output the values. Each counter can optionally have one or more attributes. For example our folder size counter can have the path attribute: this way you could have more than one instance of the same counter in a single response, each indicating a different resource. Our crate allows you to specify the attributes as slice of tuples: attribute-value. For our example we can use a vector like this:\n1 2  letmutattributes=Vec::new();attributes.push((\u0026#34;path\u0026#34;,\u0026#34;/var/log/\u0026#34;));  Now we can call the render_counter function passing the attributes and the value. Like this:\n1  pc.render_counter(Some(\u0026amp;attributes),total_size_log);  All we need to do is to append the rendered counter to the header we just obtained and we are done. Since we already have s that is a mutable String we can append (push) the correctly formatted String there:\n1  s.push_str(\u0026amp;pc.render_counter(Some(\u0026amp;attributes),total_size_log));  Result The final code is like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  usefutures::future::{done,ok,Future};useprometheus_exporter_base::{render_prometheus,PrometheusCounter};usestd::fs::read_dir;#[derive(Debug, Clone)]struct MyOptions{}fn calculate_file_size(path: \u0026amp;str)-\u0026gt; Result\u0026lt;u64,std::io::Error\u0026gt;{letmuttotal_size: u64 =0;forentryinread_dir(path)?{letp=entry?.path();ifp.is_file(){total_size+=p.metadata()?.len();}}Ok(total_size)}fn main(){letaddr=([0,0,0,0],32221).into();println!(\u0026#34;starting exporter on {}\u0026#34;,addr);render_prometheus(\u0026amp;addr,MyOptions{},|request,options|{Box::new({println!(\u0026#34;in our render_prometheus(request == {:?}, options == {:?})\u0026#34;,request,options);letfuture_log=done(calculate_file_size(\u0026#34;/var/log\u0026#34;)).from_err();future_log.and_then(|total_size_log|{letpc=PrometheusCounter::new(\u0026#34;folder_size\u0026#34;,\u0026#34;counter\u0026#34;,\u0026#34;Size of the folder\u0026#34;);letmuts=pc.render_header();letmutattributes=Vec::new();attributes.push((\u0026#34;path\u0026#34;,\u0026#34;/var/log/\u0026#34;));s.push_str(\u0026amp;pc.render_counter(Some(\u0026amp;attributes),total_size_log));ok(s)})})});}  And the result is like this one:\nConclusion Once added to Prometheus we can create beautiful dashboards like this one:\nPS: I have built a couple of exporters myself, so if you want to see a more real world examples please refer to my GitHub profile!\n Happy Coding,\nFrancesco\n","permalink":"https://blog.mindflavor.it/posts/lets-build-a-prometheus-exporter-in-rust/","summary":"Intro In this post we will build a very simple Prometheus exporter in Rust. Prometheus is a time-series database especially useful in storing and retrieving OS vital signs. It can be paired with Grafana in order to create beautiful dashboards, like this one below:\nPrometheus is peculiar because instead of receiving the events to store it goes on and retrieves them itself. There is no magic though: Prometheus just calls a preconfigured URI and expects a very specific plain text output.","title":"Let's build a Prometheus exporter in Rust"},{"content":"Intro Rust has a very rich type system. It also has move semantics. Using these two features together you can build your APIs using the builder pattern. Let\u0026rsquo;s see an actual example on why you would want to use the builder pattern and how to implement is (well, I\u0026rsquo;m showing you a way to implement it, not necessarily the best one).\nExample Suppose we have a function that takes a lot of parameters: some of them are mandatory, others are optional. For example:\n1 2 3 4 5 6 7 8 9  fn cook_pasta(pasta_type: String,pasta_name: Option\u0026lt;String\u0026gt;,pasta_length: u64,altitude: u64,water_type: Option\u0026lt;String\u0026gt;,){// your code here }  This method has two optional parameters, and three mandatory ones. Using it is ugly:\n1  cook_pasta(\u0026#34;Penne\u0026#34;.to_owned(),None,100,300,Some(\u0026#34;Salty\u0026#34;.to_owned()));  The problem here is we have to explicitly tell the method to ignore an optional field (pasta_name) and also explicitly specify the other optional field (water_type). Being an Option forces us to wrap the optional field with Some(). Also positional fields are hard to interpret. For example we have two u64 fields: without looking at the method signature is really hard to tell what\u0026rsquo;s what. Is 100 referring to the pasta_length or to the altitude? This hampers readability as we have to jump back and forth in our code just to figure out what is happening.\nWith the builder pattern we want to achieve something like this:\n1 2 3 4 5 6  cook_pasta().with_pasta_type(\u0026#34;Penne\u0026#34;.to_owned()).with_pasta_length(100).with_altitude(300).with_water_type(\u0026#34;Salty\u0026#34;.to_owned()).execute();  This syntax is really better: we know with a glance what is pasta_length (100) and what is altitude (300). Also we do not need to wrap the optional fields in Some() nor we need to use None for optional ones we do not want to pass to the function. Readability is way better at the expense of a extra execute() method call. But how to achieve it?\nBuilder struct The trick here is to have a builder object that we continually move around, adding fields in the process. The builder object will own all the method fields. Something like this:\n1 2 3 4 5 6 7 8  #[derive(Debug, Clone, Default)]struct CookPastaBuilder{pubpasta_type: String,pubpasta_name: Option\u0026lt;String\u0026gt;,pubpasta_length: u64,pubaltitude: u64,pubwater_type: Option\u0026lt;String\u0026gt;,}  Now out cook_pasta() function (we\u0026rsquo;ll call it cook_pasta2() to differentiate if from the previous version) just creates a default instance of that structure.\n1 2 3  fn cook_pasta2()-\u0026gt; CookPastaBuilder{CookPastaBuilder::default()}  Our cook_pasta code will then be run using the CookPastaBuilder defined above:\n1 2 3 4 5  implCookPastaBuilder{fn execute(\u0026amp;self){// your code here }}  As it is now you can use it like this:\n1 2 3 4 5 6 7  letmutcpb=cook_pasta2();cpb.water_type=Some(\u0026#34;Penne\u0026#34;.to_owned());cpb.pasta_length=100;cpb.altitude=300;cpb.water_type=Some(\u0026#34;Salty\u0026#34;.to_owned());cpb.execute();  Not quite what we want but better than the original method. This solution has two problems: firstly you have no way to enforce the mandatory fields. If you forget to set a mandatory field you will notice it at runtime (bad, bad, bad!). Secondly, the syntax is cumbersome. We\u0026rsquo;ll address the second issue first.\nMoving around Instead of giving access to inner fields we can expose them with moving methods. For example:\n1 2 3 4 5 6 7 8 9 10  implCookPastaBuilder{fn with_pasta_type(self,pasta_type: String)-\u0026gt; CookPastaBuilder{CookPastaBuilder{pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude: self.altitude,water_type: self.water_type,}}  Notice three things:\n We are consuming the self object. This means we can no longer call methods on it (self in the method definition). We construct a new CookPastaBuilder copying all the fields from the previous one except the field we want to assign (in the example pasta_type). We pass the newly generated CookPastaBuilder to the caller (it becomes the new owner). This way we can chain these calls as they were on the same object. In reality we are changing CookPastaBuilders at each call.  Also we can get rid of the Some() wraps putting it inside the setter function:\n1 2 3 4 5 6 7 8  fn with_water_type(self,water_type: String)-\u0026gt; CookPastaBuilder{CookPastaBuilder{pasta_type: self.pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude: self.altitude,water_type: Some(water_type),}  Now we can do this:\n1 2 3 4 5 6  cook_pasta2().with_pasta_type(\u0026#34;Penne\u0026#34;.to_owned()).with_pasta_length(100).with_altitude(300).with_water_type(\u0026#34;Salty\u0026#34;.to_owned()).execute();  Nice! But we still have to address the mandatory field check. For example this compiles fine:\n1  cook_pasta2().execute();  But it\u0026rsquo;s not fine at all (for instance, cooking pasta without actually having the pasta in the first place will not go well).\nTypes all around Suppose now we have two builders instead of one. CookPastaBuilderWithoutPastaType and CookPastaBuilderWithPastaType (yes, I know, they suck but please bear with me).\nIf we define the execute method on the WithPasta variant only we can make sure no one will be able to call it on the WithoutPasta variant. At compile time. Which is good.\nSo our logical flow will be:\n Call of cook_pasta2() will generate a CookPastaBuilderWithoutPastaType. Calling with_pasta_type(..) will consume the CookPastaBuilderWithoutPastaType and return a CookPastaBuilderWithPastaType. Now calling execute() will work because CookPastaBuilderWitPastaType implements the method.  If we were to call execute() without calling with_pasta_type(..) first we would get a compiler error.\nBut, hey, we have just handled one mandatory field. We have three of them! Sure you can come up with something like CookPastaBuilderWithoutPastaTypeWithoutAltitudeWithoutPastaLength and all the permutations (in this case 12) like CookPastaBuilderWithPastaTypeWithoutAltitudeWithPastaLength and CookPastaBuilderWithoutPastaTypeWithoutAltitudeWithPastaLength\u0026hellip; but there is a better way of doing so in less keystrokes.\nGenerics? We can use generics to achieve a better compromise. We have three mandatory fields:\n pasta_type pasta_length latitude  We can simulate the presence or absence of a value with a boolean type. Something like:\n1 2 3 4  #[derive(Debug, Default)]pubstruct Yes;#[derive(Debug, Default)]pubstruct No;  Our new class becomes:\n1  struct CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;  These generic types can either be No or Yes indicating the fact the specific field has been assigned. For example setting the pasta_type field:\n1 2 3 4 5 6 7 8 9 10 11 12  fn with_pasta_type(self,pasta_type: String,)-\u0026gt; CookPastaBuilder\u0026lt;Yes,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;{CookPastaBuilder{pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude: self.altitude,water_type: self.water_type,}}  This function will return a new CookPastaBuilder instance with the PASTA_NAME_SET set on Yes so we know the field has been set. Notice that we are returning PASTA_LENGHT_SET and ALTITUDE_SET in this case because we do not want to change the underlying type for those fields (they can either be set or not and we won\u0026rsquo;t change that here).\nDoing so for every mandatory field means we end up with a type like this:\n1  CookPastaBuilder\u0026lt;Yes,Yes,Yes\u0026gt;  This gives us the compile-time guarantee that our caller has set all the mandatory fields. All we need to do is to constrain the execution of the execute() function to this specific type:\n1 2 3 4 5  implCookPastaBuilder\u0026lt;Yes,Yes,Yes\u0026gt;{fn execute(\u0026amp;self){// your code here }}  Result From the client perspective our API is still the same, this invocation works:\n1 2 3 4 5 6  cook_pasta2().with_pasta_type(\u0026#34;Penne\u0026#34;.to_owned()).with_pasta_length(100).with_altitude(300).with_water_type(\u0026#34;Salty\u0026#34;.to_owned()).execute();  But this does not because we forgot to set the mandatory altitude parameter:\n1 2 3 4 5  cook_pasta2().with_pasta_type(\u0026#34;Penne\u0026#34;.to_owned()).with_pasta_length(100).with_water_type(\u0026#34;Salty\u0026#34;.to_owned()).execute();  The error will be like this one:\nThe no method named execute found for type CookPastaBuilder\u0026lt;Yes, Yes, No\u0026gt; in the current scope is not very helpful but at least you catch the error before runtime. At least the generic type names will help you determine what is missing:\nThat is if you add the necessary WHEREs to the struct declaration:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #[derive(Debug, Clone, Default)]pubstruct CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;wherePASTA_TYPE_SET: ToAssign,PASTA_LENGTH_SET: ToAssign,ALTITUDE_SET: ToAssign,{pasta_type_set: PhantomData\u0026lt;PASTA_TYPE_SET\u0026gt;,pasta_length_set: PhantomData\u0026lt;PASTA_LENGTH_SET\u0026gt;,altitude_set: PhantomData\u0026lt;ALTITUDE_SET\u0026gt;,pasta_type: String,pasta_name: Option\u0026lt;String\u0026gt;,pasta_length: u64,altitude: u64,water_type: Option\u0026lt;String\u0026gt;,}  Last bit: the Phantoms This is what we wanted: a builder pattern with elegant syntax, compile time checks. But we are using a fake generic, that is a generic not actively used in our code. Rust complains about this so in order to make him happy we add three new fields, one for each generic, of the type PhantomData. Do not worry, it won\u0026rsquo;t appear at runtime so there is no cost in adding it (besides the nuisance of having them at all).\nThe final code if this one. Let me know what you think about it!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159  usestd::fmt::Debug;usestd::marker::PhantomData;#[derive(Debug, Default)]pubstruct Yes;#[derive(Debug, Default)]pubstruct No;pubtraitToAssign: Debug{}pubtraitAssigned: ToAssign{}pubtraitNotAssigned: ToAssign{}implToAssignforYes{}implToAssignforNo{}implAssignedforYes{}implNotAssignedforNo{}pubfn cook_pasta(pasta_type: String,pasta_name: Option\u0026lt;String\u0026gt;,pasta_length: u64,altitude: u64,water_type: Option\u0026lt;String\u0026gt;,){// your code here println!(\u0026#34;cooking pasta! -\u0026gt; {:?}, {:?}, {:?}, {:?}, {:?}\u0026#34;,pasta_type,pasta_name,pasta_length,altitude,water_type);}#[derive(Debug, Clone, Default)]pubstruct CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;wherePASTA_TYPE_SET: ToAssign,PASTA_LENGTH_SET: ToAssign,ALTITUDE_SET: ToAssign,{pasta_type_set: PhantomData\u0026lt;PASTA_TYPE_SET\u0026gt;,pasta_length_set: PhantomData\u0026lt;PASTA_LENGTH_SET\u0026gt;,altitude_set: PhantomData\u0026lt;ALTITUDE_SET\u0026gt;,pasta_type: String,pasta_name: Option\u0026lt;String\u0026gt;,pasta_length: u64,altitude: u64,water_type: Option\u0026lt;String\u0026gt;,}impl\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;wherePASTA_TYPE_SET: ToAssign,PASTA_LENGTH_SET: ToAssign,ALTITUDE_SET: ToAssign,{pubfn with_pasta_type(self,pasta_type: String,)-\u0026gt; CookPastaBuilder\u0026lt;Yes,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;{CookPastaBuilder{pasta_type_set: PhantomData{},pasta_length_set: PhantomData{},altitude_set: PhantomData{},pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude: self.altitude,water_type: self.water_type,}}pubfn with_pasta_name(self,pasta_name: String,)-\u0026gt; CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;{CookPastaBuilder{pasta_type_set: PhantomData{},pasta_length_set: PhantomData{},altitude_set: PhantomData{},pasta_type: self.pasta_type,pasta_name: Some(pasta_name),pasta_length: self.pasta_length,altitude: self.altitude,water_type: self.water_type,}}pubfn with_pasta_length(self,pasta_length: u64,)-\u0026gt; CookPastaBuilder\u0026lt;PASTA_TYPE_SET,Yes,ALTITUDE_SET\u0026gt;{CookPastaBuilder{pasta_type_set: PhantomData{},pasta_length_set: PhantomData{},altitude_set: PhantomData{},pasta_type: self.pasta_type,pasta_name: self.pasta_name,pasta_length,altitude: self.altitude,water_type: self.water_type,}}pubfn with_altitude(self,altitude: u64,)-\u0026gt; CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,Yes\u0026gt;{CookPastaBuilder{pasta_type_set: PhantomData{},pasta_length_set: PhantomData{},altitude_set: PhantomData{},pasta_type: self.pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude,water_type: self.water_type,}}pubfn with_water_type(self,water_type: String,)-\u0026gt; CookPastaBuilder\u0026lt;PASTA_TYPE_SET,PASTA_LENGTH_SET,ALTITUDE_SET\u0026gt;{CookPastaBuilder{pasta_type_set: PhantomData{},pasta_length_set: PhantomData{},altitude_set: PhantomData{},pasta_type: self.pasta_type,pasta_name: self.pasta_name,pasta_length: self.pasta_length,altitude: self.altitude,water_type: Some(water_type),}}}implCookPastaBuilder\u0026lt;Yes,Yes,Yes\u0026gt;{pubfn execute(\u0026amp;self){// your code here println!(\u0026#34;cooking pasta! -\u0026gt; {:?}\u0026#34;,self);}}pubfn cook_pasta2()-\u0026gt; CookPastaBuilder\u0026lt;No,No,No\u0026gt;{CookPastaBuilder::default()}fn main(){cook_pasta(\u0026#34;Penne\u0026#34;.to_owned(),None,100,300,Some(\u0026#34;Salty\u0026#34;.to_owned()));cook_pasta2().with_pasta_type(\u0026#34;Penne\u0026#34;.to_owned()).with_pasta_length(100).with_water_type(\u0026#34;Salty\u0026#34;.to_owned()).with_altitude(300).execute();}   Happy Coding\nFrancesco Cogno\n","permalink":"https://blog.mindflavor.it/posts/rust-builder-pattern-with-types/","summary":"Intro Rust has a very rich type system. It also has move semantics. Using these two features together you can build your APIs using the builder pattern. Let\u0026rsquo;s see an actual example on why you would want to use the builder pattern and how to implement is (well, I\u0026rsquo;m showing you a way to implement it, not necessarily the best one).\nExample Suppose we have a function that takes a lot of parameters: some of them are mandatory, others are optional.","title":"Rust builder pattern with types"},{"content":"Games like Zork are basically big state machines. You advance in the game performing actions that lead your character from situation to situation. Eventually you either die horribly or win the game. The purpose of this post is to build a - simplified - textual game. We use it as a pretext to explore one way of treating state machines using Rust (yes, it\u0026rsquo;s a clickbaity title)\u0026hellip;\nState machines in Rust There are various ways to model a state machine in Rust. Today we build on top of a gorgeous idea by Florian Gilcher (you can see his original tweet here: https://twitter.com/Argorak/status/940221231709683713). Basically he suggests to model state passing around functions pointers. This works beautifully because you end up splitting your states in different functions instead of having a huge match statement.\nLet\u0026rsquo;s see some code first. We will comment it afterwards.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #[derive(Debug)]struct Machine;struct StateFn(fn(\u0026amp;mutMachine)-\u0026gt; StateFn);implMachine{fn start(\u0026amp;mutself)-\u0026gt; StateFn{println!(\u0026#34;start\u0026#34;);StateFn(Self::state)}fn state(\u0026amp;mutself)-\u0026gt; StateFn{println!(\u0026#34;state\u0026#34;);StateFn(Self::end)}fn end(\u0026amp;mutself)-\u0026gt; StateFn{println!(\u0026#34;end\u0026#34;);StateFn(Self::end)}}  Here we have a struct called Machine which will hold some information that will be hard to model as a state machine (empty in our case). We also define another struct, StateFn, which holds the current state (expressed as a function). The convention, here, is that each state function will accept a mutable reference of Machine and will spit out the next state.\nThe syntax might be baffling at first so let\u0026rsquo;s take a look at it. This line:\n1  struct StateFn(fn(\u0026amp;mutMachine)-\u0026gt; StateFn);  Reads: create a struct called StateFn. This struct will have one implicit field. This field will accept only function pointers. The function pointed must have a single parameter - mutable reference of Machine - and will return a owned StateFn.\nThe state machine depicted above is this one:\nTo \u0026ldquo;run\u0026rdquo; it we can use this simple code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  fn main(){letmutm=Machine;letmutc=StateFn(Machine::start);println!(\u0026#34;m == {:?}\u0026#34;,m);c=c.0(\u0026amp;mutm);println!(\u0026#34;m == {:?}\u0026#34;,m);c=c.0(\u0026amp;mutm);println!(\u0026#34;m == {:?}\u0026#34;,m);c=c.0(\u0026amp;mutm);println!(\u0026#34;m == {:?}\u0026#34;,m);c=c.0(\u0026amp;mutm);println!(\u0026#34;m == {:?}\u0026#34;,m);}  The c.0() syntax allows us to extract the first implicit field of StateFn and call it as a function. We pass the function our world state which is a Machine instance. Reassigning our StateFn binding simulates the evolution of the state machine. We can remove that .0 function call implementing Deref.\nDeref Florian Gilcher gives us an elegant solution to get rid of the c.0() dereference. Rust allows us to implement custom deref behavior using the Deref trait. Let\u0026rsquo;s do this:\n1 2 3 4 5 6 7  implDerefforStateFn{type Target=fn(\u0026amp;mutMachine)-\u0026gt; StateFn;fn deref(\u0026amp;self)-\u0026gt; \u0026amp;Self::Target{\u0026amp;self.0}}  With this code we can simplify this call:\n1  c=c.0(\u0026amp;mutm);  with this one:\n1  c=c(\u0026amp;mutm);  So, to recap, we pass around functions that represent our state in the state machine. The functions will manipulate our world. With this information we can implement our Zork clone!\nThe game The game will be very simple: there will be just three rooms. This is the state machine of our game:\nHere we have two \u0026ldquo;game-related\u0026rdquo; variables:\n Player owns the key or not Player has opened the door or not  Also, to give interactivity, we store in our \u0026ldquo;world\u0026rdquo; the command input by the player. Each state can inspect the command issued and act accordingly. For example we have a magic fountain in a room. The player may issue: \u0026ldquo;drink from the fountain\u0026rdquo;. If we are in the right room we can let the avatar drink from the fountain. The same command can be invalid in another room though. Lastly we store the player name.\nWe can model it just like this:\n1 2 3 4 5 6 7 8 9 10 11 12  #[derive(Debug)]struct Player{name: String,has_key: bool,}#[derive(Debug)]struct Game{player: Player,last_command: String,door_locked: bool,}  Notice we have both \u0026ldquo;game-related\u0026rdquo; variables and \u0026ldquo;technical\u0026rdquo; variables jumbled together. This might not be desiderable: we could rid of the \u0026ldquo;game-related\u0026rdquo; variable by replacing them via specialized states. For example, instead of having a single room state we can have room_door_locked and room_door_unlocked. Something like this:\nThe text processor In order to build a text-based game you have to handle free form text. Given this is a sample of a Rust state machine I will cheat and just match predefined strings. For example the room with the key can be written like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  fn key_room_with_key(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dark room.\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dark room. You see a key on the floor.\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}\u0026#34;pick up the key\u0026#34;=\u0026gt;{println!(\u0026#34;You gingerly pick up the key and store it for later use.\u0026#34;);self.player.has_key=true;StateStruct::input_required(Self::key_room_empty)}\u0026#34;go back\u0026#34;=\u0026gt;{println!(\u0026#34;You go back in the hallway.\u0026#34;);StateStruct::no_input_required(Self::hallway)}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}}}  As you can see we just match for specific input strings. Remember, the last received command will be in the last_command field. We than do three things:\n Print something to give feedback to the user. Change the world (optional) modifying our mutable reference. Move to the new state. Here we use two helper functions, input_required and no_input_required to signal if we have to wait for player input before activating the new state.  Main The main method is just a loop. We start the state machine in the start state and play the state machine until we reach the end state. The main loop is oblivious of what\u0026rsquo;s happening in the state machine, the state transition happen as result of state execution.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  fn main(){usestd::io::Write;letmutgame=Game::default();// start the state machine. letmutsf=StateStruct::no_input_required(Game::start);// process the start state and progress to the next state. sf=sf(\u0026amp;mutgame);// we play the machine until its end. while!sf.completed{// if the state requires input we ask the player to supply it. ifsf.requires_input{letmutbuffer=String::new();print!(\u0026#34;\u0026gt; \u0026#34;);::std::io::stdout().flush().unwrap();::std::io::stdin().read_line(\u0026amp;mutbuffer).unwrap();game.last_command=buffer[0..buffer.len()-1].to_owned();}else{game.last_command=\u0026#34;\u0026#34;.to_owned();}// now we play the next state and advance the machine. sf=sf(\u0026amp;mutgame);}}  As you can see the main code is straightforward.\nWrapping up Now all we have to do is to implement the states our game will handle. The following complete code will implement the diagram above. Can you complete the dungeon without dying? Also, can you devise a more challenging dungeon to play? Let me know!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273  usestd::ops::Deref;type StateFn\u0026lt;T\u0026gt;=fn(\u0026amp;mutT)-\u0026gt; StateStruct\u0026lt;T\u0026gt;;struct StateStruct\u0026lt;T\u0026gt;{function: StateFn\u0026lt;T\u0026gt;,requires_input: bool,completed: bool,}impl\u0026lt;T\u0026gt;StateStruct\u0026lt;T\u0026gt;{fn new(function: StateFn\u0026lt;T\u0026gt;,requires_input: bool,completed: bool)-\u0026gt; StateStruct\u0026lt;T\u0026gt;{StateStruct{function: function,requires_input: requires_input,completed: completed,}}fn input_required(function: StateFn\u0026lt;T\u0026gt;)-\u0026gt; StateStruct\u0026lt;T\u0026gt;{StateStruct::new(function,true,false)}fn no_input_required(function: StateFn\u0026lt;T\u0026gt;)-\u0026gt; StateStruct\u0026lt;T\u0026gt;{StateStruct::new(function,false,false)}fn completed(function: StateFn\u0026lt;T\u0026gt;)-\u0026gt; StateStruct\u0026lt;T\u0026gt;{StateStruct::new(function,false,true)}}impl\u0026lt;T\u0026gt;DerefforStateStruct\u0026lt;T\u0026gt;{type Target=StateFn\u0026lt;T\u0026gt;;fn deref(\u0026amp;self)-\u0026gt; \u0026amp;Self::Target{\u0026amp;self.function}}#[derive(Debug)]struct Player{name: String,has_key: bool,}#[derive(Debug)]struct Game{player: Player,last_command: String,door_locked: bool,}impl::std::default::DefaultforGame{fn default()-\u0026gt; Self{Game{player: Player{name: \u0026#34;\u0026#34;.to_owned(),has_key: false,},door_locked: true,last_command: \u0026#34;\u0026#34;.to_owned(),}}}implGame{fn reset(\u0026amp;mutself){self.player.has_key=false;self.door_locked=true;}fn start(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{println!(\u0026#34;You wake up in hallway. Your memory is fuzzy... What\u0026#39;s your name?\u0026#34;);StateStruct::input_required(Self::save_name)}fn end(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{println!(\u0026#34;You eneded the game! {} wins! Congrats!\u0026#34;,self.player.name);StateStruct::completed(Self::end)}fn save_name(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{::std::mem::swap(\u0026amp;mutself.player.name,\u0026amp;mutself.last_command);println!(\u0026#34;Yes, that\u0026#39;s right! You are {}!\u0026#34;,self.player.name);StateStruct::no_input_required(Self::hallway)}fn hallway(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a hallway. You can inspect it, go left or right.\u0026#34;);StateStruct::input_required(Self::hallway)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a hallway. It\u0026#39;s unremarkable. You can go either right or left.\u0026#34;);StateStruct::input_required(Self::hallway)}\u0026#34;go left\u0026#34;=\u0026gt;{println!(\u0026#34;You run left until you reach a dead end.\u0026#34;);if!self.player.has_key{StateStruct::no_input_required(Self::key_room_with_key)}else{StateStruct::no_input_required(Self::key_room_empty)}}\u0026#34;go right\u0026#34;=\u0026gt;{println!(\u0026#34;You run left until you reach a dead end.\u0026#34;);ifself.door_locked{StateStruct::no_input_required(Self::door_room_locked)}else{StateStruct::no_input_required(Self::door_room_unlocked)}}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::hallway)}}}fn key_room_with_key(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dark room.\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dark room. You see a key on the floor.\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}\u0026#34;pick up the key\u0026#34;=\u0026gt;{println!(\u0026#34;You gingerly pick up the key and store it for later use.\u0026#34;);self.player.has_key=true;StateStruct::input_required(Self::key_room_empty)}\u0026#34;go back\u0026#34;=\u0026gt;{println!(\u0026#34;You go back in the hallway.\u0026#34;);StateStruct::no_input_required(Self::hallway)}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::key_room_with_key)}}}fn key_room_empty(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dark room.\u0026#34;);StateStruct::input_required(Self::key_room_empty)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You look around but there is nothing worth mentioning.\u0026#34;);StateStruct::input_required(Self::key_room_empty)}\u0026#34;pick up the key\u0026#34;=\u0026gt;{println!(\u0026#34;There is no key to pick up!\u0026#34;);StateStruct::input_required(Self::key_room_empty)}\u0026#34;go back\u0026#34;=\u0026gt;{println!(\u0026#34;You go back in the hallway.\u0026#34;);StateStruct::no_input_required(Self::hallway)}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::key_room_empty)}}}fn door_room_locked(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dimly lit room.\u0026#34;);StateStruct::input_required(Self::door_room_locked)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dimly lit room. You notice a sickly looking fountain and a door.\u0026#34;);StateStruct::input_required(Self::door_room_locked)}\u0026#34;drink from the fountain\u0026#34;=\u0026gt;{println!(\u0026#34;You drink the water and drop dead immediately. Tough luck!\u0026#34;);self.reset();StateStruct::no_input_required(Self::start)}\u0026#34;unlock the door\u0026#34;=\u0026gt;{ifself.player.has_key{println!(\u0026#34;You use your key to unlock the door.\u0026#34;);self.door_locked=false;StateStruct::input_required(Self::door_room_unlocked)}else{println!(\u0026#34;You do not have a key to use!\u0026#34;);StateStruct::input_required(Self::door_room_locked)}}\u0026#34;open the door\u0026#34;=\u0026gt;{println!(\u0026#34;The door is locked! You must find a key first!\u0026#34;);StateStruct::input_required(Self::door_room_locked)}\u0026#34;go back\u0026#34;=\u0026gt;{println!(\u0026#34;You go back in the hallway.\u0026#34;);StateStruct::no_input_required(Self::hallway)}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::door_room_locked)}}}fn door_room_unlocked(\u0026amp;mutself)-\u0026gt; StateStruct\u0026lt;Game\u0026gt;{match\u0026amp;self.last_commandas\u0026amp;str{\u0026#34;\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dimly lit room.\u0026#34;);StateStruct::input_required(Self::door_room_unlocked)}\u0026#34;inspect\u0026#34;=\u0026gt;{println!(\u0026#34;You are in a dimly lit room. You notice a sickly looking fountain and an already unlocked door.\u0026#34;);StateStruct::input_required(Self::door_room_unlocked)}\u0026#34;drink from the fountain\u0026#34;=\u0026gt;{println!(\u0026#34;You drink the water and drop dead immediately. Tough luck!\u0026#34;);self.reset();StateStruct::no_input_required(Self::start)}\u0026#34;unlock the door\u0026#34;=\u0026gt;{println!(\u0026#34;The door is already unlocked!\u0026#34;);StateStruct::input_required(Self::door_room_unlocked)}\u0026#34;open the door\u0026#34;=\u0026gt;{println!(\u0026#34;You open the door and escape the dungeon!\u0026#34;,);StateStruct::no_input_required(Self::end)}\u0026#34;go back\u0026#34;=\u0026gt;{println!(\u0026#34;You go back in the hallway.\u0026#34;);StateStruct::no_input_required(Self::hallway)}_=\u0026gt;{println!(\u0026#34;I don\u0026#39;t know how to do that! What do you want to do?\u0026#34;);StateStruct::input_required(Self::door_room_unlocked)}}}}fn main(){usestd::io::Write;letmutgame=Game::default();letmutsf=StateStruct::no_input_required(Game::start);sf=sf(\u0026amp;mutgame);while!sf.completed{// println!(\u0026#34;game == {:?}\u0026#34;, game); ifsf.requires_input{letmutbuffer=String::new();print!(\u0026#34;\u0026gt; \u0026#34;);::std::io::stdout().flush().unwrap();::std::io::stdin().read_line(\u0026amp;mutbuffer).unwrap();game.last_command=buffer[0..buffer.len()-1].to_owned();}else{game.last_command=\u0026#34;\u0026#34;.to_owned();}sf=sf(\u0026amp;mutgame);}}   Happy Coding,\nFrancesco Cogno\n","permalink":"https://blog.mindflavor.it/posts/zork-rust/","summary":"Games like Zork are basically big state machines. You advance in the game performing actions that lead your character from situation to situation. Eventually you either die horribly or win the game. The purpose of this post is to build a - simplified - textual game. We use it as a pretext to explore one way of treating state machines using Rust (yes, it\u0026rsquo;s a clickbaity title)\u0026hellip;\nState machines in Rust There are various ways to model a state machine in Rust.","title":"Let's build Zork using Rust!"}]